# 2rabbits
A Proof of Concept implementation of the Advanced Rejection Sampling Algorithm for covert information leakage.

# Building

Run the `install.sh` script;

Next, build with cmake:
```bash
cmake --build ./build --config Debug --target all --
```

# Watermarking tool

To use the watermarking tool, first build the binaries. Then, you can use:

```bash
./bin/watermarking help
```

to show options. In general, usage looks like this:

## Generating a lookup table

To generate a lookup table run the `watermarking` binary with `g` option:

```bash
watermarking [-v] g[enerate_lut] '/save/path' '/path/to/enc_key.pub' (m) [C] 'dual_key'
```

### Parameters:
1. `[-v]`: [OPTIONAL] verbose mode. `[-vv]` is debug mode
2. `'/save/path'`: Save location of the generated lookup table.
3. `'/path/to/enc_key.pub`': Path to PEM-encoded ECDSA public key used to encrypt the anamorphic message
4. `(m)`: Number of bits to be encrypted (width of the anamorphic channel). 0 < m < 17
5. `[C]`: [OPTIONAL] Number of records in a row of the lookup table. Default is 5
6. `'dual_key'`: String used as a dual key to encrypt the anamorphic message.

### Example usage: 

```bash
$ ./bin/watermarking -v generate_lut lut.out ./keys/ec-secp256k1-pub-key_enc.pem 4 'testing key'
```

The serialized lookup table is required for anamorphic signing.

## Signing and encrypting

To sign a message and encrypt a watermark, use the `watermarking` binary with option `s`:

```bash
watermarking [-v] s[ign] '/path/to/lut' '/path/to/sign_key.priv' '/path/to/enc_key.pub' 'message_to_sign' 'watermark' 'dual_key' ['delta']
```

### Parameters:
1. `[-v]`: [OPTIONAL] verbose mode. `[-vv]` is debug mode
2. `'/path/to/lut'`: Path to a lookup table generated by the command `g`
3. `'/path/to/sign_key.priv'`: Path to PEM-encoded ECDSA signing key used to sign the `'message_to_sign'`
4. `/path/to/enc_key.pub`: Path to PEM-encoded ECDSA public key used to encrypt the `'watermark'`
5. `'message_to_sign'`: Message to be signed with private key
6. `'watermark'`: Message to be encrypted inside of the signature
7. `'dual_key'`: String used as a dual key to encrypt the 'watermark'
8. `['delta']`: [OPTIONAL] Public string to be used for encryption. Default is the timestamp of the signature

### Example usage

```bash
watermarking s lut.out ./keys/ec-secp256k1-priv-key.pem ./keys/ec-secp256k1-pub-key_enc.pem 'test message' 'bb' 'testing dual key' 'delta1'
```

The signature will verify with 'normal' openssl verification as well. You can check it with command like this (fill in your signature hexstring and signed message):

```bash
$ openssl dgst -sha3-256 -verify ./keys/ec-secp256k1-pub-key.pem -signature <(echo "<SIGNATURE HEXSTRING>" | xxd -r -p) <(echo -e -n '<SIGNED MESSAGE>') 

Verified OK
```



## Verifying and decrypting

To verify the signature and decrypt the anamorphic message, run the `watermarking` binary with option `d`:

```bash
./bin/watermarking [-v] d[ecrypt] '/path/to/sign_key.pub' '/path/to/enc_key.priv' 'signature' 'message_to_verify' (m) 'dual_key' 'delta'
```

### Parameters:
1. `[-v]`: [OPTIONAL] verbose mode. `[-vv]` is debug mode
2. `'/path/to/sign_key.pub'`: Path to PEM-encoded ECDSA signing public key used to verify the `'message_to_verify'`
3. `'/path/to/enc_key.priv'`: Path to PEM-encoded ECDSA private key used to decrypt the anamorphic message
4. `'signature'`: Hex-encoded signature to verify and decrypt from
'message_to_verify': Message to be verified with the public key
5. `(m)`: Number of bits to be decrypted (width of the anamorphic channel). 0 < m < 17
6. `'dual_key'`: String used as a dual key to decrypt the anamorphic message
7. `'delta'`: Public string to be used for decryption. By default its the timestamp of the signature

### Example usage

```bash
watermarking d ./keys/ec-secp256k1-pub-key.pem ./keys/ec-secp256k1-priv-key_enc.pem "3046022100D3E2F45231AD5064F4E7B179C08F8DBCE1382B4417136515D5FF82EC3AB0BF3E0221009DF15
08201F320D2EF7A9A3077EAD64B33AD0A461B67054CEC379902D2091590" 'test message' 16 'testing key
' 'delta'
```
The recovered message should be the same as provided in the signing step. If its not, check if you're using the same `dual_key`, `delta`, `m`, lookup table, keys and of course sign message!

# Tests

To run tests, first build the binaries and cd into the bin folder

```bash
cd ./bin
```

Then run the test binaries with no arguments (they can take some time):

```bash
./test* 
```

Make sure that the keys are generated in the `{root-git}/keys` directory!